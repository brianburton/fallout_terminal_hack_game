#!/usr/bin/env ruby

require 'set'

# Generate words
# Loop
  # display words (include likeness if tried)
  # display tries remaining
  # read word
  # score word

class Word
  attr_reader :text, :likeness, :tried
  attr_writer :tried

  def initialize(text, likeness)
    @text = text
    @likeness = likeness
    @tried = true
  end

  def is_password
    return text.length == likeness
  end

  def length
    return @text.length
  end

  def <=>(other)
      text <=> other
  end

  def to_s
    @tried ? "#{@text} (#{@likeness})" : @text
  end
end

class WordList
  attr_reader :words

  def initialize(words)
    @words = words
  end

  def word_length
    @words[0].length
  end

  def length
    @words.length
  end

  def playable?
    above_half_length = (word_length + 1) / 2
    above_half_count = 0
    @words.each do |word|
      above_half_count += 1 if word.likeness >= above_half_length
    end
    return above_half_count.to_f >= (length.to_f / 2.75)
  end

  def tries
    @words.sum { |w| w.tried ? 1 : 0 }
  end

  def reset
    @words.each { |w| w.tried = false }
  end
end

class Game
  attr_reader :word_length, :num_words, :max_tries, :num_tries, :words

end

class WordMap
  def initialize
    @words = Hash.new {|hash,key| hash[key] = Array.new}
    File.open("words.txt", "r") do |f|
      f.each do |line|
        line = line.chomp.downcase
        next unless line.length >= 4
        next unless line.length <= 10
        @words[line.length] << line
      end
    end
  end

  def likeness(pwd, other)
    answer = 0
    (0...pwd.length).each do |i|
      answer += 1 if pwd[i] == other[i]
    end
    return answer
  end

  def random_words(length, num_words)
    all_words = @words[length]
    raise "insufficient words" if all_words.length < num_words
    1.upto(1000000).each do |try_number|
      answer = Set.new
      pwd = nil
      while answer.length < num_words
        word = all_words[rand(all_words.length)]
        if pwd.nil?
          pwd = word
          answer << Word.new(word, length)
        else
          word_likeness = likeness(pwd, word)
          next if word_likeness < 1 || word_likeness == length
          answer << Word.new(word, word_likeness)
        end
      end
      words = WordList.new(answer.to_a)
      return answer.to_a.sort if words.words if words.playable?
    end
    raise "unable to find enough words with non-zero likeness"
  end
end

class GameMenu
  attr_reader :words

  def initialize(words)
    @words = words
  end

  def print
    choice = 1
    @words.each do |word|
      prefix = ""
      if word.tried
        prefix = "  "
      else
        prefix = "#{choice})"
        choice += 1
      end
      STDIO.print "#{prefix} #{word}\n"
    end
    STDIO.print "r) RESTART\n"
  end

  def map(c)
    return c if c == "r"
    c = c.to_i
    choice = 1
    @words.each do |word|
      unless word.tried
        return word if c == choice
        choice += 1
      end
    end
    return nil
  end

  def read
    while true
      STDIO.print "#{4 - @words.tries} remaining: "
      choice = STDIN.read_line.chomp
      if choice.length > 0
        mapped = map(choice)
        return mapped unless mapped.nil?
      end
    end
  end
end

class GameLoop
  attr_reader :words

  def initialize(words)
    @words = words
  end

  def run
    
  end
end

wm = WordMap.new
(4..8).each do |length|
  (5..12).each do |num_words|
    puts "NEW: length=#{length} num_words=#{num_words}"
    puts wm.random_words(length, num_words)
  end
end
